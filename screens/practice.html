<div class="practice-screen min-vh-100 d-flex flex-column" style="background: #000000;" role="region" aria-label="Practice session screen">
  <!-- Video Feed Container -->
  <div class="position-relative flex-grow-1">
    <!-- Video Element -->
    <video id="practiceVideo" autoplay playsinline class="w-100 h-100" style="object-fit: cover;" aria-label="Camera feed for pose detection"></video>
    
    <!-- Canvas Overlay for Skeleton -->
    <canvas id="poseCanvas" class="position-absolute top-0 start-0 w-100 h-100" style="pointer-events: none;" aria-hidden="true"></canvas>
    
    <!-- Posture Feedback Badge (Top Left) -->
    <div class="position-absolute top-0 start-0 m-3" style="z-index: 10;">
      <div class="badge-card bg-dark bg-opacity-75 backdrop-blur p-3 rounded-3 border border-cyan scale-in">
        <div class="d-flex align-items-center gap-2 mb-2">
          <i class="bi bi-person-standing text-cyan" aria-hidden="true"></i>
          <small class="text-muted">Posture</small>
        </div>
        <div class="d-flex align-items-center gap-2">
          <div class="progress flex-grow-1" style="height: 8px; width: 100px;" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Posture score">
            <div id="postureBar" class="progress-bar bg-gradient" role="presentation" style="width: 0%; background: linear-gradient(90deg, #06b6d4, #10b981);"></div>
          </div>
          <strong id="postureScore" class="text-cyan" aria-live="polite">0%</strong>
        </div>
        <small id="postureFeedback" class="text-success d-block mt-1" aria-live="polite" aria-atomic="true">Stand straight</small>
      </div>
    </div>
    
    <!-- Timer (Top Right) -->
    <div class="position-absolute top-0 end-0 m-3" style="z-index: 10;">
      <div class="badge-card bg-dark bg-opacity-75 backdrop-blur p-3 rounded-3 border border-purple text-center scale-in">
        <i class="bi bi-clock text-purple mb-1" aria-hidden="true"></i>
        <h4 id="sessionTimer" class="mb-0 text-purple fw-bold" style="font-family: 'Courier New', monospace;" aria-live="polite" aria-label="Session time">00:00</h4>
      </div>
    </div>
    
    <!-- end of video container -->
  </div>

  <!-- BPM Detector (moved out of video overlay; sits above controls) -->
  <div class="px-3 pb-2" style="z-index:10;">
    <div class="bg-dark bg-opacity-90 backdrop-blur rounded-3 p-3 border border-purple scale-in">
      <div class="d-flex align-items-center justify-content-between">
        <div class="d-flex align-items-center gap-3 flex-grow-1">
          <div id="bpmPulse" class="rounded-circle d-flex align-items-center justify-content-center" style="width: 45px; height: 45px; background: rgba(168, 85, 247, 0.2);" aria-hidden="true">
            <i class="bi bi-music-note-beamed text-purple fs-5"></i>
          </div>
          <div class="flex-grow-1">
            <small class="text-muted d-block">Beat Detection</small>
            <h5 id="bpmDisplay" class="mb-0 text-purple fw-bold" aria-live="polite" aria-label="BPM detection">-- BPM</h5>
          </div>
        </div>
        <button class="btn btn-sm btn-outline-purple" onclick="tapSync()" aria-label="Tap to sync with beat">
          <i class="bi bi-hand-index-thumb me-1" aria-hidden="true"></i>
          Tap Sync
        </button>
      </div>

      <!-- Beat Visualizer -->
      <div class="d-flex gap-1 mt-2" id="beatVisualizer" aria-hidden="true">
        <div class="beat-bar flex-grow-1 bg-secondary rounded" style="height: 4px;"></div>
        <div class="beat-bar flex-grow-1 bg-secondary rounded" style="height: 4px;"></div>
        <div class="beat-bar flex-grow-1 bg-secondary rounded" style="height: 4px;"></div>
        <div class="beat-bar flex-grow-1 bg-secondary rounded" style="height: 4px;"></div>
        <div class="beat-bar flex-grow-1 bg-secondary rounded" style="height: 4px;"></div>
        <div class="beat-bar flex-grow-1 bg-secondary rounded" style="height: 4px;"></div>
        <div class="beat-bar flex-grow-1 bg-secondary rounded" style="height: 4px;"></div>
        <div class="beat-bar flex-grow-1 bg-secondary rounded" style="height: 4px;"></div>
      </div>
      <!-- Music library picker (appears under beat detection) -->
      <div class="d-flex justify-content-center mt-3" aria-hidden="false">
        <button id="libraryPickerBtn" class="btn btn-outline-purple btn-sm" 
          onclick="showInternalLibrary()" 
           aria-label="Choose audio from internal library">
          <i class="bi bi-music-note-list me-1" aria-hidden="true"></i>
          Choose From Library
        </button>
      </div>
      <!-- Track choices (per-genre selection) -->
      <div id="trackChoices" class="d-flex gap-2 justify-content-center flex-wrap mt-3" aria-live="polite"></div>
      <!-- Internal library picker (hidden by default) -->
      <div id="internalLibrary" class="bg-dark bg-opacity-95 border border-secondary rounded mt-3 p-2" style="display:none; max-height:220px; overflow:auto;" aria-hidden="true"></div>
    </div>
  </div>
  
  <!-- Bottom Controls Panel -->
  <div class="controls-panel bg-dark border-top border-secondary p-3">
    <!-- Motion Stats Row -->
    <div class="row g-2 mb-3">
      <div class="col-4">
        <div class="stat-mini bg-gradient-to-r from-cyan-900 to-transparent border border-cyan rounded-2 p-2 text-center">
          <i class="bi bi-footprints text-cyan d-block mb-1" aria-hidden="true"></i>
          <h6 id="stepCount" class="mb-0 fw-bold text-cyan" aria-label="Steps count" aria-live="polite">0</h6>
          <small class="text-muted" style="font-size: 10px;">Steps</small>
        </div>
      </div>
      <div class="col-4">
        <div class="stat-mini bg-gradient-to-r from-pink-900 to-transparent border border-pink rounded-2 p-2 text-center">
          <i class="bi bi-arrow-repeat text-pink d-block mb-1" aria-hidden="true"></i>
          <h6 id="turnCount" class="mb-0 fw-bold text-pink" aria-label="Turns count" aria-live="polite">0</h6>
          <small class="text-muted" style="font-size: 10px;">Turns</small>
        </div>
      </div>
      <div class="col-4">
        <div class="stat-mini bg-gradient-to-r from-purple-900 to-transparent border border-purple rounded-2 p-2 text-center">
          <i class="bi bi-lightning text-purple d-block mb-1" aria-hidden="true"></i>
          <h6 id="energyLevel" class="mb-0 fw-bold text-purple" aria-label="Energy level" aria-live="polite">0</h6>
          <small class="text-muted" style="font-size: 10px;">Energy</small>
        </div>
      </div>
    </div>
    
    <!-- Control Buttons -->
    <div class="d-flex gap-2">
      <button id="pauseBtn" class="btn btn-success flex-grow-1 py-2" onclick="togglePause()" aria-label="Start practice session" aria-pressed="false">
        <i class="bi bi-play-fill me-2" aria-hidden="true"></i>
        <span id="pauseBtnText">Start Session</span>
      </button>
      <div class="d-flex flex-column align-items-center">
        <button id="musicToggleBtn" class="btn btn-outline-secondary mb-2" onclick="toggleMusic()" aria-label="Toggle background music">
          <i id="musicToggleIcon" class="bi bi-volume-up"></i>
        </button>
        <button id="uploadMusicBtn" class="btn btn-outline-secondary" onclick="document.getElementById('musicFileInput').click()" aria-label="Upload track">
          <i class="bi bi-upload me-1 upload-icon" aria-hidden="true"></i>Upload
        </button>
        <input id="musicFileInput" type="file" accept="audio/*" style="display:none" onchange="handleMusicFile(event)" />
        <div id="currentTrackName" class="small text-muted mt-2" aria-live="polite" style="max-width:120px; text-overflow:ellipsis; white-space:nowrap; overflow:hidden;">No track selected</div>
      </div>
      <button id="endSessionBtn" class="btn btn-danger flex-grow-1 py-2" onclick="endSession()" aria-label="End practice session">
        <i class="bi bi-stop-fill me-2" aria-hidden="true"></i>
        End Session
      </button>
      <button class="btn btn-dark px-3 py-3" onclick="Navigation.navigate('home')" aria-label="Close practice and return home">
        <i class="bi bi-x-lg" aria-hidden="true"></i>
      </button>
    </div>
  </div>
</div>

<style>
.backdrop-blur {
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

.badge-card {
  min-width: 120px;
}

#bpmPulse {
  animation: pulse 0.6s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.8; }
}

.beat-bar {
  transition: all 0.1s ease;
}

.beat-bar.active {
  background: var(--neon-purple) !important;
  height: 8px !important;
}

.btn-outline-purple {
  border-color: var(--neon-purple);
  color: var(--neon-purple);
}

.btn-outline-purple:hover {
  background: var(--neon-purple);
  color: white;
}

/* Compact horizontal music bar under beat detector */
.music-bar {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 6px 8px;
}
.track-list {
  display: flex;
  gap: 6px;
  align-items: center;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  max-width: 62%;
}
.track-chip {
  flex: 0 0 auto;
  padding: 6px 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.04);
  color: var(--neon-purple, #a855f7);
  border: 1px solid rgba(255,255,255,0.04);
  font-size: 12px;
}
.track-chip.selected {
  background: linear-gradient(90deg, rgba(168,85,247,0.13), rgba(99,102,241,0.08));
  border-color: rgba(168,85,247,0.6);
  box-shadow: 0 2px 8px rgba(99,102,241,0.08);
}
.track-btn {
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
.btn.selected {
  border-color: rgba(168,85,247,0.6) !important;
  box-shadow: 0 4px 12px rgba(99,102,241,0.08);
  background: linear-gradient(90deg, rgba(168,85,247,0.06), rgba(99,102,241,0.03));
}
.music-actions {
  display:flex; gap:6px; align-items:center; justify-content:center; flex:0 0 auto;
}
.controls-panel .btn {
  font-size: 0.95rem;
}
#pauseBtn, #endSessionBtn {
  padding-top: 0.25rem; /* keep padding small but enforce height */
  padding-bottom: 0.25rem;
  height: 44px; /* enforce primary button height */
  min-height: 44px;
}
#pauseBtn i, #endSessionBtn i {
  font-size: 1.05rem;
}
#uploadMusicBtn .upload-icon {
  font-size: 0.95rem;
  vertical-align: middle;
}
#uploadMusicBtn {
  padding: 0.15rem 0.45rem;
  font-size: 0.9rem;
  height: 32px; /* small button height */
  min-height: 32px;
}
/* make music toggle also compact */
#musicToggleBtn { height: 32px; min-height: 32px; padding: 0.15rem 0.4rem; }
.current-track {
  flex: 0 0 18%;
  text-align: right;
  font-size: 12px;
  color: #94a3b8;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* internal library panel becomes a compact dropdown overlay */
#internalLibrary {
  position: absolute;
  /* will be positioned dynamically near the picker button */
  left: 0;
  top: 0;
  bottom: auto;
  display: none;
  z-index: 1050;
  min-width: 320px;
  max-width: 90%;
}
</style>

<script>
let sessionActive = false;
let sessionPaused = false;
let sessionStartTime = null;
let sessionPauseStart = null; // timestamp when pause began
let timerInterval = null;
let tapTimes = [];

// Initialize practice screen
async function initPracticeScreen() {
  console.log('üé¨ Initializing practice screen...');
  
  try {
    // Reset session state so "Practice Again" starts fresh
    try {
      sessionPaused = false;
      sessionActive = false;
      tapTimes = [];
      if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
      // Session data is managed centrally by `Session` module
    } catch (e) {
      console.warn('Could not fully reset session state:', e);
    }

    // Get video and canvas elements
    const video = document.getElementById('practiceVideo');
    const canvas = document.getElementById('poseCanvas');
    
    // Start camera preview only. Session (detection, audio, motion, timer)
    // will start when the user clicks the "Start Session" button.
    await CameraModule.startCamera(video, canvas);
    console.log('‚úÖ Camera preview started (session not started)');
    // Try to restore previously chosen audio handle (Chromium-only). This will
    // load the file into MusicPlayer but will not autoplay.
    try {
      if (typeof tryRestoreUserAudio === 'function') {
        tryRestoreUserAudio().catch(err => console.warn('restore audio failed:', err));
      }
    } catch (e) {
      console.warn('Audio restore skipped:', e);
    }
    // Render curated track choices for the selected routine (if any)
    try {
      let routineName = null;
      if (window.Database && Database.getSelectedRoutine) {
        try { routineName = await Database.getSelectedRoutine(); } catch (e) { routineName = null; }
      }
      if (!routineName && Session && Session.data && Session.data.routineName) routineName = Session.data.routineName;
      if (!routineName) routineName = 'Freestyle';
      try { await renderTrackChoices(routineName); } catch (e) { console.warn('renderTrackChoices failed:', e); }
      // Restore last internal selection visually if present
      try {
        if (window.Database && Database.getSetting) {
          const last = await Database.getSetting('lastInternalTrack', null);
          if (last && last.url) {
            const el = document.getElementById('currentTrackName');
            if (el) el.textContent = last.name || basename(last.url);
            // highlight selection in track choices and internal library (if rendered later)
            markSelectedTrack(last);
          }
        }
      } catch (e) { /* ignore */ }
    } catch (e) { /* ignore */ }
    
  } catch (error) {
    console.error('‚ùå Failed to initialize practice screen:', error);
    alert('Failed to start practice session. Please check camera permissions.');
    Navigation.navigate('home');
  }
}

// Session timer
function startSessionTimer() {
  // prevent multiple timers from being created
  if (timerInterval) return;
  sessionStartTime = Date.now();
  
  timerInterval = setInterval(() => {
    if (!sessionPaused) {
      const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
      // duration is managed by Session; keep local UI fallback minimal
      
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      document.getElementById('sessionTimer').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
  }, 1000);
}

// Update posture display
function updatePosture(score) {
  const scoreElement = document.getElementById('postureScore');
  const barElement = document.getElementById('postureBar');
  const feedbackElement = document.getElementById('postureFeedback');
  
  scoreElement.textContent = Math.round(score) + '%';
  barElement.style.width = score + '%';
  
  // Update feedback text
  if (score >= 85) {
    feedbackElement.textContent = 'Excellent! üåü';
    feedbackElement.className = 'text-success d-block mt-1';
  } else if (score >= 70) {
    feedbackElement.textContent = 'Good form üëç';
    feedbackElement.className = 'text-success d-block mt-1';
  } else if (score >= 50) {
    feedbackElement.textContent = 'Keep improving';
    feedbackElement.className = 'text-warning d-block mt-1';
  } else {
    feedbackElement.textContent = 'Straighten up';
    feedbackElement.className = 'text-danger d-block mt-1';
  }
}

// Update BPM display
function updateBPM(bpm) {
  document.getElementById('bpmDisplay').textContent = Math.round(bpm) + ' BPM';
  
  // Animate beat visualizer
  const bars = document.querySelectorAll('.beat-bar');
  const activeBar = Math.floor(Date.now() / (60000 / bpm)) % bars.length;
  
  bars.forEach((bar, i) => {
    if (i === activeBar) {
      bar.classList.add('active');
      setTimeout(() => bar.classList.remove('active'), 100);
    }
  });
}

// Update motion stats
function updateMotionStats(data) {
  if (data.steps !== undefined) {
    document.getElementById('stepCount').textContent = data.steps;
  }
  
  if (data.turns !== undefined) {
    document.getElementById('turnCount').textContent = data.turns;
  }
  
  if (data.energy !== undefined) {
    // Session.data will carry the canonical energy value; UI updated here
    document.getElementById('energyLevel').textContent = Math.round(data.energy);
  }
}

// Tap sync for manual BPM
function tapSync() {
  const now = Date.now();
  tapTimes.push(now);
  
  // Keep only last 4 taps
  if (tapTimes.length > 4) {
    tapTimes.shift();
  }
  
  // Calculate BPM from taps
  if (tapTimes.length >= 2) {
    const intervals = [];
    for (let i = 1; i < tapTimes.length; i++) {
      intervals.push(tapTimes[i] - tapTimes[i-1]);
    }
    
    const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
    const bpm = 60000 / avgInterval;
    
    updateBPM(bpm);
  }
}

// Try to restore previously chosen audio handle (Chromium-only)
async function tryRestoreUserAudio() {
  try {
    if (!Database || !Database.getSetting) return;

    const handle = await Database.getSetting('userAudioHandle', null);
    if (!handle) return;

    // If this is a File System FileHandle (Chrome), it will have a getFile() method
    if (handle && typeof handle.getFile === 'function') {
      // Try to query permissions if available
      try {
        if (typeof handle.queryPermission === 'function') {
          const perm = await handle.queryPermission({ mode: 'read' });
          if (perm !== 'granted' && typeof handle.requestPermission === 'function') {
            const req = await handle.requestPermission({ mode: 'read' });
            if (req !== 'granted') {
              console.warn('User denied access to stored audio handle');
              return;
            }
          } else if (perm !== 'granted' && typeof handle.requestPermission !== 'function') {
            // cannot request permission programmatically; abort
            console.warn('No permission to read stored audio handle');
            return;
          }
        }
      } catch (e) {
        // Non-fatal: continue and attempt to get file
        console.warn('Permission check for stored handle failed:', e);
      }

      const file = await handle.getFile();
      if (file && typeof MusicPlayer !== 'undefined') {
        MusicPlayer.loadFile(file);
        const el = document.getElementById('currentTrackName');
        if (el) el.textContent = file.name;
        if (Session && Session.data) Session.data.trackName = file.name;
      }
    }
  } catch (e) {
    console.warn('Could not restore persisted user audio:', e);
  }
}

// Toggle pause
function togglePause() {
  const btn = document.getElementById('pauseBtn');
  const btnText = document.getElementById('pauseBtnText');

  // If session never started, start it now via Session module
  if (!sessionActive) {
    // Hook Session callbacks to UI update functions
    Session.onPosture = (score) => {
      updatePosture(score);
    };
    Session.onBPM = (bpm) => {
      updateBPM(bpm);
    };
    Session.onMotion = (data) => {
      updateMotionStats(data);
    };
    Session.onTick = (formatted, seconds) => {
      document.getElementById('sessionTimer').textContent = formatted;
    };

    // Start session
    Session.start().catch(e => console.warn('Session.start failed:', e));

    sessionActive = true;
    sessionPaused = false;

    btn.className = 'btn btn-warning flex-grow-1 py-3';
    btn.setAttribute('aria-pressed', 'false');
    btn.setAttribute('aria-label', 'Pause practice session');
    btnText.textContent = 'Pause';
    btn.querySelector('i').className = 'bi bi-pause-fill me-2';

    // Start visuals (pulse)
    try { const pulse = document.getElementById('bpmPulse'); if (pulse) pulse.style.animationPlayState = 'running'; } catch (e) {}

    return;
  }

  // If session active, toggle pause/resume using Session
  if (!sessionPaused) {
    // Pause
    Session.pause();
    sessionPaused = true;

    btn.className = 'btn btn-success flex-grow-1 py-3';
    btn.setAttribute('aria-pressed', 'true');
    btn.setAttribute('aria-label', 'Resume practice session');
    btnText.textContent = 'Resume';
    btn.querySelector('i').className = 'bi bi-play-fill me-2';

    // Pause visuals
    try { const pulse = document.getElementById('bpmPulse'); if (pulse) pulse.style.animationPlayState = 'paused'; } catch (e) {}
    try { const bars = document.querySelectorAll('.beat-bar'); bars.forEach(b => b.classList.remove('active')); } catch (e) {}
    try { const bpmDisplay = document.getElementById('bpmDisplay'); if (bpmDisplay) bpmDisplay.textContent = '-- BPM'; } catch (e) {}

  } else {
    // Resume
    Session.resume();
    sessionPaused = false;

    btn.className = 'btn btn-warning flex-grow-1 py-3';
    btn.setAttribute('aria-pressed', 'false');
    btn.setAttribute('aria-label', 'Pause practice session');
    btnText.textContent = 'Pause';
    btn.querySelector('i').className = 'bi bi-pause-fill me-2';

    // Resume visuals
    try { const pulse = document.getElementById('bpmPulse'); if (pulse) pulse.style.animationPlayState = 'running'; } catch (e) {}
  }
}

// Music controls
function toggleMusic() {
  try {
    const icon = document.getElementById('musicToggleIcon');
    if (!window.MusicPlayer) return;

    if (MusicPlayer.isPlaying) {
      MusicPlayer.pause();
      if (icon) icon.className = 'bi bi-volume-mute';
    } else {
      // Try to play current routine track or loaded file
      const routine = (Session && Session.data && Session.data.routineName) || null;
      MusicPlayer.play(routine, { loop: true }).then(() => {
        if (icon) icon.className = 'bi bi-volume-up';
      }).catch(() => {
        if (icon) icon.className = 'bi bi-volume-off';
      });
    }
  } catch (e) {
    console.warn('toggleMusic error:', e);
  }
}

function handleMusicFile(event) {
  const f = event.target.files && event.target.files[0];
  if (!f) return;
  try {
    const url = MusicPlayer.loadFile(f);
    // remember chosen track in session data
    if (Session && Session.data) Session.data.trackName = f.name;
    MusicPlayer.playLoaded({ loop: true }).then(() => {
      const icon = document.getElementById('musicToggleIcon');
      if (icon) icon.className = 'bi bi-volume-up';
    }).catch(err => {
      console.warn('playLoaded failed:', err);
    });
  } catch (e) {
    console.warn('handleMusicFile error:', e);
  }
}

// Feature-detect and try File System Access API
async function pickUserAudioWithFSAPI() {
  // Only in Chromium-based browsers
  if (!window.showOpenFilePicker) return null;

  try {
    const [handle] = await window.showOpenFilePicker({
      types: [{
        description: 'Audio files',
        accept: { 'audio/*': ['.mp3', '.m4a', '.wav', '.ogg', '.flac'] }
      }],
      excludeAcceptAllOption: false,
      multiple: false
    });

    // Persist handle if supported (IndexedDB can store it in Chromium)
    try {
      if (window.Database && Database.saveSetting) {
        await Database.saveSetting('userAudioHandle', handle);
      }
    } catch (e) {
      console.warn('Could not persist file handle:', e);
    }

    const file = await handle.getFile();
    handleMusicFile({ target: { files: [file] } }); // reuse existing handler
    return true;
  } catch (e) {
    console.warn('pickUserAudioWithFSAPI cancelled/failed:', e);
    return null;
  }
}

// Fallback wrapper called from UI
async function pickUserAudio() {
  // Try FS API first
  const r = await pickUserAudioWithFSAPI();
  if (r) return;
  // Otherwise trigger file input (existing control)
  document.getElementById('musicFileInput').click();
}

// Helpers for rendering per-genre track choices
function normalizeRoutineKey(name) {
  if (!name) return null;
  return name.toString().toLowerCase().replace(/[^a-z0-9]+/g, '').trim();
}

function basename(path) {
  if (!path) return '';
  try { return path.split('/').pop(); } catch (e) { return path; }
}

// Render up to 5 tracks for the current routine key into #trackChoices
function renderTrackChoices(routineName) {
  try {
    console.log('renderTrackChoices called with routineName:', routineName);
    const key = normalizeRoutineKey(routineName || (Session && Session.data && Session.data.routineName) || null);
    console.log('normalized key:', key);
    const container = document.getElementById('trackChoices');
    if (!container) return;
    container.innerHTML = '';

    let tracks = (window.MusicPlayer && MusicPlayer.getTracksForKey) ? MusicPlayer.getTracksForKey(key) : [];
    // If no tracks found for normalized key, try a few fallbacks (raw, without spaces/hyphens)
    if ((!tracks || tracks.length === 0) && routineName) {
      const raw = String(routineName).toLowerCase();
      const noSpaces = raw.replace(/\s+/g, '');
      const noHyphens = raw.replace(/-/g, '');
      const candidates = [raw, noSpaces, noHyphens];
      for (const c of candidates) {
        if (!c) continue;
        const tryTracks = MusicPlayer.getTracksForKey(c);
        if (tryTracks && tryTracks.length) {
          tracks = tryTracks;
          console.log('renderTrackChoices: found tracks using fallback key:', c);
          break;
        }
      }
    }
    console.log('renderTrackChoices: tracks found:', (tracks || []).length);

    if (!tracks || tracks.length === 0) {
      // No predefined tracks for this routine; show a subtle hint
      const hint = document.createElement('div');
      hint.className = 'small text-muted';
      hint.textContent = 'No curated tracks for this routine. Upload or choose from library.';
      container.appendChild(hint);
      return;
    }
    // Create horizontal track chips that are touch-friendly and selectable
    const listDiv = document.createElement('div');
    listDiv.className = 'track-list';
    tracks.slice(0,5).forEach((t, idx) => {
      const chip = document.createElement('div');
      chip.className = 'track-chip track-btn';
      chip.style.maxWidth = '160px';
      chip.title = basename(t);
      chip.textContent = basename(t);
      chip.dataset.genre = key;
      chip.dataset.index = idx;
      chip.dataset.url = t;
      chip.onclick = async (e) => {
        e.preventDefault();
        try {
          await MusicPlayer.playTrack(key, idx, { loop: true });
          const el = document.getElementById('currentTrackName');
          if (el) el.textContent = basename(t);
          if (Session && Session.data) {
            Session.data.trackName = basename(t);
            Session.data.trackIndex = idx;
          }
          const icon = document.getElementById('musicToggleIcon');
          if (icon) icon.className = 'bi bi-volume-up';
          // persist last internal selection
          try { if (window.Database && Database.saveSetting) {
              await Database.saveSetting('lastInternalTrack', { genre: key, index: idx, url: t, name: basename(t) });
            }} catch(e){/* ignore */}
          // visually mark selected
          markSelectedTrack({ genre: key, index: idx, url: t, name: basename(t) });
        } catch (err) {
          console.warn('Failed to play selected track:', err);
        }
      };
      listDiv.appendChild(chip);
    });
    container.appendChild(listDiv);
  } catch (e) {
    console.warn('renderTrackChoices error:', e);
  }
}

// When practice initializes, renderTrackChoices is called from initPracticeScreen

// INTERNAL LIBRARY UI
function getAllInternalTracks() {
  try {
    const map = (window.AppConfig && AppConfig.AUDIO_MAP) ? AppConfig.AUDIO_MAP : {};
    const list = [];
    Object.keys(map).forEach(key => {
      const val = map[key];
      if (Array.isArray(val)) {
        val.forEach((t, idx) => list.push({ genre: key, url: t, index: idx }));
      } else if (val) {
        list.push({ genre: key, url: val, index: 0 });
      }
    });
    return list;
  } catch (e) { return []; }
}

function showInternalLibrary() {
  try {
    const container = document.getElementById('internalLibrary');
    if (!container) return;
    // Toggle visibility
    if (container.style.display && container.style.display !== 'none') {
      container.style.display = 'none';
      container.setAttribute('aria-hidden', 'true');
      return;
    }

    container.innerHTML = '';
    const list = getAllInternalTracks();
    if (!list || list.length === 0) {
      const no = document.createElement('div');
      no.className = 'small text-muted px-2';
      no.textContent = 'No internal tracks available.';
      container.appendChild(no);
      container.style.display = 'block';
      container.setAttribute('aria-hidden', 'false');
      return;
    }

    // Group by genre for a compact list
    const grouped = {};
    list.forEach(item => {
      grouped[item.genre] = grouped[item.genre] || [];
      grouped[item.genre].push(item);
    });

    Object.keys(grouped).forEach(genre => {
      const header = document.createElement('div');
      header.className = 'fw-bold text-cyan small mt-1 mb-1';
      header.textContent = genre.charAt(0).toUpperCase() + genre.slice(1);
      container.appendChild(header);

      const row = document.createElement('div');
      row.className = 'd-flex gap-2 flex-wrap mb-2';

      grouped[genre].slice(0,5).forEach(item => {
        const btn = document.createElement('button');
        btn.className = 'btn btn-sm btn-outline-purple track-btn';
        btn.style.maxWidth = '160px';
        btn.title = basename(item.url);
        btn.textContent = basename(item.url);
        btn.dataset.url = item.url;
        btn.dataset.genre = genre;
        btn.dataset.index = item.index;
        btn.onclick = async (e) => {
          e.preventDefault();
          try {
            // Use MusicPlayer.play with direct URL (or playTrack for genre/index)
            if (MusicPlayer && MusicPlayer.play) {
              await MusicPlayer.play(item.url, { loop: true });
            }
            const el = document.getElementById('currentTrackName');
            if (el) el.textContent = basename(item.url);
            if (Session && Session.data) {
              Session.data.trackName = basename(item.url);
              Session.data.trackSource = 'internal';
            }
            // persist selection for quick restore next time
            try { if (window.Database && Database.saveSetting) {
                await Database.saveSetting('lastInternalTrack', { genre: genre, index: item.index, url: item.url, name: basename(item.url) });
              }} catch (e) { /* ignore */ }
            // close library UI
            container.style.display = 'none';
            container.setAttribute('aria-hidden', 'true');
            const icon = document.getElementById('musicToggleIcon');
            if (icon) icon.className = 'bi bi-volume-up';
          } catch (err) {
            console.warn('Failed to play internal track:', err);
          }
        };
        row.appendChild(btn);
      });

      container.appendChild(row);
    });

    // Add a small close hint
    const hint = document.createElement('div');
    hint.className = 'small text-muted px-2';
    hint.textContent = 'Tap a track to play. Tap the button again to close.';
    container.appendChild(hint);

    // Position the panel near the picker button so it doesn't block camera
    const picker = document.getElementById('libraryPickerBtn');
    if (picker) {
      const rect = picker.getBoundingClientRect();
      // place above the controls-panel and centered to the picker
      const panel = container;
      const panelWidth = Math.min(window.innerWidth * 0.9, 420);
      panel.style.minWidth = Math.min(panelWidth, 420) + 'px';
      // Use fixed positioning near the picker for stable overlay behavior
      panel.style.position = 'fixed';
      panel.style.left = Math.max(8, (rect.left + rect.width / 2) - (panelWidth / 2)) + 'px';
      // place slightly above the picker button
      panel.style.top = Math.max(8, rect.top - panel.offsetHeight - 12) + 'px';
      panel.style.bottom = 'auto';
      panel.style.zIndex = 2000;
    }

    container.style.display = 'block';
    container.setAttribute('aria-hidden', 'false');

    // Close when clicking outside or pressing Escape
    setTimeout(() => {
      const onDocClick = (ev) => {
        const c = document.getElementById('internalLibrary');
        const btn = document.getElementById('libraryPickerBtn');
        if (!c) return;
        if (c.contains(ev.target) || (btn && btn.contains(ev.target))) return;
        c.style.display = 'none';
        c.setAttribute('aria-hidden', 'true');
        document.removeEventListener('click', onDocClick);
        document.removeEventListener('keydown', onEsc);
      };
      const onEsc = (ev) => {
        if (ev.key === 'Escape') {
          const c = document.getElementById('internalLibrary');
          if (!c) return;
          c.style.display = 'none';
          c.setAttribute('aria-hidden', 'true');
          document.removeEventListener('click', onDocClick);
          document.removeEventListener('keydown', onEsc);
        }
      };
      document.addEventListener('click', onDocClick);
      document.addEventListener('keydown', onEsc);
    }, 50);
  } catch (e) {
    console.warn('showInternalLibrary error:', e);
  }
}

// Mark selected track visually in both trackChoices and internalLibrary
function markSelectedTrack(sel) {
  try {
    if (!sel) return;
    const name = sel.name || basename(sel.url || sel);
    // update current track name
    const cur = document.getElementById('currentTrackName');
    if (cur) cur.textContent = name;

    // clear previous selections
    document.querySelectorAll('.track-chip.selected').forEach(n => n.classList.remove('selected'));
    // mark trackChoices chips
    document.querySelectorAll('#trackChoices .track-chip').forEach(ch => {
      if (ch.dataset && (ch.dataset.url === sel.url || (sel.genre && ch.dataset.genre === sel.genre && String(ch.dataset.index) === String(sel.index)))) {
        ch.classList.add('selected');
      }
    });

    // mark internal library buttons
    const lib = document.getElementById('internalLibrary');
    if (lib) {
      lib.querySelectorAll('button').forEach(b => {
        b.classList.remove('selected');
        const url = b.dataset && b.dataset.url ? b.dataset.url : null;
        // some internal buttons are plain; compare by text if needed
        if (url && sel.url && url === sel.url) {
          b.classList.add('selected');
        } else if (!url && sel.name && b.textContent && b.textContent.trim() === sel.name) {
          b.classList.add('selected');
        }
      });
    }

  } catch (e) { /* ignore */ }
}


// End session
async function endSession() {
  if (!confirm('End this practice session?')) {
    return;
  }
  
  try {
    // Use Session.end() to finalize and save
    clearInterval(timerInterval);
    CameraModule.stopCamera();
    const summary = await (Session.end ? Session.end() : (async () => null)());

    // If Session.end returned a summary, use it; otherwise build a fallback
    const finalSession = summary || {
      date: new Date().toISOString(),
      duration: formatDuration((Session && Session.data && Session.data.duration) || 0),
      score: 0,
      avgBPM: 0,
      steps: (Session && Session.data && Session.data.steps) || 0,
      turns: (Session && Session.data && Session.data.turns) || 0,
      energy: (Session && Session.data && Session.data.energy) || 0,
      routineName: await Database.getSelectedRoutine() || 'Freestyle'
    };

    sessionStorage.setItem('lastSessionSummary', JSON.stringify(finalSession));

    if (typeof Navigation !== 'undefined' && Navigation.navigate) {
      Navigation.navigate('summary');
    } else {
      window.location.href = '/';
    }
  } catch (error) {
    console.error('‚ùå Error ending session:', error);
    // Fallback: retour √† la home
    if (typeof Navigation !== 'undefined' && Navigation.navigate) {
      Navigation.navigate('home');
    } else {
      window.location.href = '/';
    }
  }
}

function formatDuration(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Initialize when screen loads
initPracticeScreen();
</script>